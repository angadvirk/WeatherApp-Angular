{"ast":null,"code":"import * as Highcharts from 'highcharts';\nimport more from 'highcharts/highcharts-more';\nimport windbarb from 'highcharts/modules/windbarb';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../data.service\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"highcharts-angular\";\n\nfunction MeteogramComponent_div_1_highcharts_chart_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"highcharts-chart\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"Highcharts\", ctx_r1.Highcharts)(\"options\", ctx_r1.meteogramOptions)(\"callbackFunction\", ctx_r1.chartCallback);\n  }\n}\n\nfunction MeteogramComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵtemplate(1, MeteogramComponent_div_1_highcharts_chart_1_Template, 1, 3, \"highcharts-chart\", 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isHighcharts);\n  }\n} // import exporting from 'highcharts/modules/exporting';\n// import offline-exporting from 'highcharts/modules/offline-exporting';\n\n\nmore(Highcharts);\nwindbarb(Highcharts);\nexport let MeteogramComponent = /*#__PURE__*/(() => {\n  class MeteogramComponent {\n    // updateFlag: boolean = false;\n    // oneToOneFlag: boolean = true;\n    // runOutsideAngular: boolean = false;\n    constructor(dataService) {\n      this.dataService = dataService;\n      this.showMeteogram = false; // Highcharts variables\n\n      this.isHighcharts = typeof Highcharts === 'object';\n      this.Highcharts = Highcharts; // Meteogram Data Variables\n\n      this.hourlyHourData = [];\n      this.hourlyTempData = [];\n      this.hourlyHumidityData = [];\n      this.hourlyPressureData = [];\n      this.hourlyWindData = []; // chartConstructor: string = 'chart';\n\n      this.meteogramOptions = {};\n\n      this.chartCallback = function (arg) {};\n    }\n\n    smoothLine(data) {\n      var i = data.length,\n          sum,\n          value;\n\n      while (i--) {\n        data[i].value = value = data[i].y; // preserve value for tooltip\n        // Set the smoothed value to the average of the closest points, but don't allow\n        // it to differ more than 0.5 degrees from the given value\n\n        sum = (data[i - 1] || data[i]).y + value + (data[i + 1] || data[i]).y;\n        data[i].y = Math.max(value - 0.5, Math.min(sum / 3, value + 0.5));\n      }\n    }\n\n    drawBlocksForWindArrows(chart) {\n      var xAxis = chart.xAxis[0],\n          x,\n          pos,\n          max,\n          isLong,\n          isLast,\n          i;\n\n      for (pos = xAxis.min, max = xAxis.max, i = 0; pos <= max + 36e5; pos += 36e5, i += 1) {\n        // Get the X position\n        isLast = pos === max + 36e5;\n        x = Math.round(xAxis.toPixels(pos)) + (isLast ? 0.5 : -0.5); // Draw the vertical dividers and ticks\n\n        isLong = true; // if (this.resolution > 36e5) {\n        //     isLong = pos % this.resolution === 0;\n        // } else {\n        //     isLong = i % 2 === 0;\n        // }\n\n        chart.renderer.path(['M', x, chart.plotTop + chart.plotHeight + (isLong ? 0 : 28), 'L', x, chart.plotTop + chart.plotHeight + 32, 'Z']).attr({\n          stroke: chart.options.chart.plotBorderColor,\n          'stroke-width': 1\n        }).add();\n      } // Center items in block\n\n\n      chart.get('windbarbs').markerGroup.attr({\n        translateX: chart.get('windbarbs').markerGroup.translateX + 3\n      });\n    }\n\n    onChartLoad(chart) {// this.drawBlocksForWindArrows(chart);\n    }\n\n    getMeteogramOptions() {\n      var meteogram = this;\n      meteogram.meteogramOptions = {\n        chart: {\n          // renderTo: this.container,\n          marginBottom: 70,\n          marginRight: 40,\n          marginTop: 50,\n          plotBorderWidth: 1,\n          height: 400,\n          alignTicks: false,\n          scrollablePlotArea: {\n            minWidth: 600\n          }\n        },\n        exporting: {\n          chartOptions: {\n            plotOptions: {\n              series: {\n                dataLabels: {\n                  enabled: true\n                }\n              }\n            }\n          },\n          fallbackToExportServer: false\n        },\n        title: {\n          text: \"Hourly Weather (Fot Next 5 Days)\"\n        },\n        tooltip: {\n          shared: true,\n          useHTML: true,\n          headerFormat: '<small>{point.x:%A, %b %e, %H:%M}</small><br>' + '<b>{point.point.symbolName}</b><br>'\n        },\n        xAxis: [{\n          type: 'datetime',\n          tickInterval: 4 * 36e5,\n          minorTickInterval: 36e5,\n          tickLength: 0,\n          gridLineWidth: 1,\n          gridLineColor: 'rgba(128, 128, 128, 0.1)',\n          startOnTick: false,\n          endOnTick: false,\n          minPadding: 0,\n          maxPadding: 0,\n          offset: 30,\n          showLastLabel: true,\n          labels: {\n            format: '{value:%H}'\n          },\n          crosshair: true\n        }, {\n          linkedTo: 0,\n          type: 'datetime',\n          tickInterval: 24 * 3600 * 1000,\n          labels: {\n            format: '{value:<span style=\"font-size: 12px; font-weight: bold\">%a</span> %b %e}',\n            align: 'left',\n            x: 3,\n            y: -5\n          },\n          opposite: true,\n          tickLength: 20,\n          gridLineWidth: 1\n        }],\n        yAxis: [{\n          title: {\n            text: null\n          },\n          labels: {\n            format: '{value}°',\n            style: {\n              fontSize: '10px'\n            },\n            x: -3\n          },\n          plotLines: [{\n            value: 0,\n            color: '#BBBBBB',\n            width: 1,\n            zIndex: 2\n          }],\n          maxPadding: 0.3,\n          minRange: 8,\n          tickInterval: 1,\n          gridLineColor: 'rgba(128, 128, 128, 0.1)'\n        }, {\n          title: {\n            text: null\n          },\n          labels: {\n            enabled: false\n          },\n          gridLineWidth: 0,\n          tickLength: 0,\n          minRange: 10,\n          min: 0\n        }, {\n          allowDecimals: false,\n          title: {\n            text: 'inHg',\n            offset: 0,\n            align: 'high',\n            rotation: 0,\n            style: {\n              fontSize: '10px',\n              color: \"rgba(250, 149, 18, 1)\"\n            },\n            textAlign: 'left',\n            x: 3\n          },\n          // tickInterval: 1,\n          labels: {\n            style: {\n              fontSize: '8px',\n              color: \"rgba(250, 149, 18, 1)\"\n            },\n            y: 2,\n            x: 3\n          },\n          // tickPositions: [0, 29, 60],\n          gridLineWidth: 0,\n          opposite: true,\n          showLastLabel: false\n        }],\n        legend: {\n          enabled: false\n        },\n        plotOptions: {\n          series: {\n            // pointStart: this.hourlyHourData[0], // start at the appropriate hour\n            pointPlacement: 'between'\n          }\n        },\n        series: [{\n          name: 'Temperature',\n          data: this.hourlyTempData,\n          type: 'spline',\n          marker: {\n            enabled: false,\n            states: {\n              hover: {\n                enabled: true\n              }\n            }\n          },\n          tooltip: {\n            valueSuffix: \"°F\"\n          },\n          clip: false,\n          zIndex: 1,\n          // tickInterval: 6,\n          color: '#FF3333',\n          negativeColor: '#48AFE8'\n        }, {\n          name: 'Humidity',\n          data: this.hourlyHumidityData,\n          // data: this.precipitations,\n          type: 'column',\n          color: '#76C2FE',\n          yAxis: 1,\n          groupPadding: 0,\n          pointPadding: 0,\n          grouping: false,\n          dataLabels: {\n            enabled: true,\n            formatter: function () {\n              if (this.y > 0) {\n                return Math.round(this.y); // no decimals\n              }\n\n              return 0;\n            },\n            style: {\n              fontSize: '8px',\n              color: 'gray'\n            }\n          },\n          tooltip: {\n            valueSuffix: ' %'\n          }\n        }, {\n          name: 'Air pressure',\n          type: 'spline',\n          color: \"rgba(250, 149, 18, 1)\",\n          data: this.hourlyPressureData,\n          dashStyle: \"ShortDot\",\n          marker: {\n            enabled: false\n          },\n          shadow: false,\n          tooltip: {\n            valueSuffix: ' inHg'\n          },\n          yAxis: 2\n        }, {\n          name: 'Wind',\n          type: 'windbarb',\n          id: 'windbarbs',\n          color: 'red',\n          lineWidth: 1.5,\n          data: this.hourlyWindData,\n          vectorLength: 9,\n          yOffset: -15,\n          tooltip: {\n            valueSuffix: ' mph'\n          }\n        }]\n      };\n    }\n\n    createChart() {\n      var meteogram = this;\n      this.getMeteogramOptions(); // Draw wind arrows\n\n      this.chartCallback = function (chart) {\n        meteogram.onChartLoad(chart);\n      };\n    }\n\n    parseYrData() {\n      // Smooth the line\n      this.smoothLine(this.hourlyTempData); // Create the chart when the data is loaded\n\n      this.createChart();\n    }\n\n    ngOnInit() {\n      this.dataService.tomorrowObject.subscribe(data => {\n        if (Object.keys(data).length > 0) {\n          // Update Meteogram Options Data\n          let hourlyHourData = [];\n          let hourlyTempData = [];\n          let hourlyHumidityData = [];\n          let hourlyPressureData = [];\n          let hourlyWindData = [];\n\n          for (let i = 0; i < data.data.timelines[0].intervals.length; i++) {\n            hourlyHourData.push(new Date(data.data.timelines[0].intervals[i].startTime).getTime());\n            hourlyTempData.push([hourlyHourData[i], data.data.timelines[0].intervals[i].values.temperature]);\n            hourlyHumidityData.push([hourlyHourData[i], data.data.timelines[0].intervals[i].values.humidity]);\n            hourlyPressureData.push([hourlyHourData[i], data.data.timelines[0].intervals[i].values.pressureSeaLevel]);\n\n            if (i % 2 === 0) {\n              // get wind data for every even-numbered hour\n              hourlyWindData.push([hourlyHourData[i], data.data.timelines[0].intervals[i].values.windSpeed, data.data.timelines[0].intervals[i].values.windDirection]);\n            }\n          }\n\n          let meteoData = [hourlyHourData, hourlyTempData, hourlyHumidityData, hourlyPressureData, hourlyWindData];\n          this.hourlyHourData = hourlyHourData;\n          this.hourlyTempData = hourlyTempData;\n          this.hourlyHumidityData = hourlyHumidityData;\n          this.hourlyPressureData = hourlyPressureData;\n          this.hourlyWindData = hourlyWindData;\n          this.parseYrData(); // Show Meteogram\n\n          this.showMeteogram = true;\n        }\n      });\n    }\n\n  }\n\n  MeteogramComponent.ɵfac = function MeteogramComponent_Factory(t) {\n    return new (t || MeteogramComponent)(i0.ɵɵdirectiveInject(i1.DataService));\n  };\n\n  MeteogramComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: MeteogramComponent,\n    selectors: [[\"app-meteogram\"]],\n    decls: 2,\n    vars: 1,\n    consts: [[\"class\", \"container\", 4, \"ngIf\"], [1, \"container\"], [\"style\", \"width: 100%; height: 400px; display: block;\", 3, \"Highcharts\", \"options\", \"callbackFunction\", 4, \"ngIf\"], [2, \"width\", \"100%\", \"height\", \"400px\", \"display\", \"block\", 3, \"Highcharts\", \"options\", \"callbackFunction\"]],\n    template: function MeteogramComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"br\");\n        i0.ɵɵtemplate(1, MeteogramComponent_div_1_Template, 2, 1, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showMeteogram);\n      }\n    },\n    directives: [i2.NgIf, i3.HighchartsChartComponent],\n    styles: [\"\"]\n  });\n  return MeteogramComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}